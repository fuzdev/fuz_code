{
	"name": "@fuzdev/fuz_code",
	"repo_name": "fuz_code",
	"repo_url": "https://github.com/fuzdev/fuz_code",
	"owner_name": "fuzdev",
	"homepage_url": "https://code.fuz.dev/",
	"logo_url": "https://code.fuz.dev/logo.svg",
	"logo_alt": "a friendly pink spider facing you",
	"npm_url": "https://www.npmjs.com/package/@fuzdev/fuz_code",
	"changelog_url": "https://github.com/fuzdev/fuz_code/blob/main/CHANGELOG.md",
	"published": true,
	"package_json": {
		"name": "@fuzdev/fuz_code",
		"version": "0.44.1",
		"description": "syntax styling utilities and components for TypeScript, Svelte, and Markdown",
		"glyph": "ðŸŽ¨",
		"logo": "logo.svg",
		"logo_alt": "a friendly pink spider facing you",
		"license": "MIT",
		"homepage": "https://code.fuz.dev/",
		"repository": "https://github.com/fuzdev/fuz_code",
		"author": {
			"name": "Ryan Atkinson",
			"email": "mail@ryanatkn.com",
			"url": "https://www.ryanatkn.com/"
		},
		"bugs": "https://github.com/fuzdev/fuz_code/issues",
		"funding": "https://www.ryanatkn.com/funding",
		"scripts": {
			"start": "gro dev",
			"dev": "gro dev",
			"build": "gro build",
			"check": "gro check",
			"test": "gro test",
			"preview": "vite preview",
			"deploy": "gro deploy",
			"benchmark": "gro run benchmark/run_benchmarks.ts",
			"benchmark:compare": "gro run benchmark/compare/run_compare.ts",
			"fixtures:update": "gro src/test/fixtures/update"
		},
		"type": "module",
		"engines": {
			"node": ">=22.15"
		},
		"peerDependencies": {
			"@fuzdev/fuz_css": ">=0.47.0",
			"@fuzdev/fuz_util": ">=0.49.2",
			"esm-env": "^1",
			"magic-string": "^0.30",
			"svelte": "^5",
			"zimmerframe": "^1"
		},
		"peerDependenciesMeta": {
			"@fuzdev/fuz_css": {
				"optional": true
			},
			"@fuzdev/fuz_util": {
				"optional": true
			},
			"magic-string": {
				"optional": true
			},
			"svelte": {
				"optional": true
			},
			"zimmerframe": {
				"optional": true
			}
		},
		"devDependencies": {
			"@changesets/changelog-git": "^0.2.1",
			"@fuzdev/fuz_css": "^0.47.0",
			"@fuzdev/fuz_ui": "^0.182.0",
			"@fuzdev/fuz_util": "^0.50.1",
			"@jridgewell/trace-mapping": "^0.3.31",
			"@ryanatkn/eslint-config": "^0.9.0",
			"@ryanatkn/gro": "^0.191.0",
			"@sveltejs/adapter-static": "^3.0.10",
			"@sveltejs/kit": "^2.50.1",
			"@sveltejs/package": "^2.5.7",
			"@sveltejs/vite-plugin-svelte": "^6.2.4",
			"@types/estree": "^1.0.8",
			"@types/node": "^24.10.1",
			"@webref/css": "^8.2.0",
			"eslint": "^9.39.1",
			"eslint-plugin-svelte": "^3.13.1",
			"esm-env": "^1.2.2",
			"magic-string": "^0.30.21",
			"prettier": "^3.7.4",
			"prettier-plugin-svelte": "^3.4.1",
			"svelte": "^5.49.1",
			"svelte-check": "^4.3.6",
			"svelte2tsx": "^0.7.47",
			"tslib": "^2.8.1",
			"typescript": "^5.9.3",
			"typescript-eslint": "^8.48.1",
			"vitest": "^4.0.15",
			"zimmerframe": "^1.1.4",
			"zod": "^4.3.6"
		},
		"prettier": {
			"plugins": ["prettier-plugin-svelte"],
			"useTabs": true,
			"printWidth": 100,
			"singleQuote": true,
			"bracketSpacing": false,
			"overrides": [
				{
					"files": "package.json",
					"options": {
						"useTabs": false
					}
				}
			]
		},
		"sideEffects": ["**/*.css"],
		"files": ["dist", "src/lib/**/*.ts", "!src/lib/**/*.test.*", "!dist/**/*.test.*"],
		"exports": {
			"./package.json": "./package.json",
			"./*.js": {
				"types": "./dist/*.d.ts",
				"default": "./dist/*.js"
			},
			"./*.ts": {
				"types": "./dist/*.d.ts",
				"default": "./dist/*.js"
			},
			"./*.svelte": {
				"types": "./dist/*.svelte.d.ts",
				"svelte": "./dist/*.svelte",
				"default": "./dist/*.svelte"
			},
			"./*.css": {
				"default": "./dist/*.css"
			}
		}
	},
	"source_json": {
		"name": "@fuzdev/fuz_code",
		"version": "0.44.1",
		"modules": [
			{
				"path": "code_sample.ts",
				"declarations": [
					{
						"name": "CodeSample",
						"kind": "type",
						"source_line": 1,
						"type_signature": "CodeSample",
						"properties": [
							{
								"name": "name",
								"kind": "variable",
								"type_signature": "string"
							},
							{
								"name": "lang",
								"kind": "variable",
								"type_signature": "string"
							},
							{
								"name": "content",
								"kind": "variable",
								"type_signature": "string"
							}
						]
					},
					{
						"name": "sample_langs",
						"kind": "variable",
						"source_line": 8,
						"type_signature": "readonly [\"json\", \"css\", \"ts\", \"html\", \"svelte\", \"md\"]"
					},
					{
						"name": "SampleLang",
						"kind": "type",
						"source_line": 10,
						"type_signature": "\"json\" | \"css\" | \"ts\" | \"html\" | \"svelte\" | \"md\""
					}
				]
			},
			{
				"path": "Code.svelte",
				"declarations": [
					{
						"name": "Code",
						"kind": "component",
						"props": [
							{
								"name": "lang",
								"type": "string | null",
								"optional": true,
								"description": "Language identifier (e.g., 'ts', 'css', 'html', 'json', 'svelte', 'md').\n\n**Purpose:**\n- When `grammar` is not provided, used to look up the grammar via `syntax_styler.get_lang(lang)`\n- Used for metadata: sets the `data-lang` attribute and determines `language_supported`\n\n**Special values:**\n- `null` - Explicitly disables syntax highlighting (content rendered as plain text)\n- `undefined` - Falls back to default ('svelte')\n\n**Relationship with `grammar`:**\n- If both `lang` and `grammar` are provided, `grammar` takes precedence for tokenization\n- However, `lang` is still used for the `data-lang` attribute and language detection"
							},
							{
								"name": "grammar",
								"type": "SyntaxGrammar | undefined",
								"optional": true,
								"description": "Optional custom grammar object for syntax tokenization.\n\n**When to use:**\n- To provide a custom language definition not registered in `syntax_styler.langs`\n- To use a modified/extended version of an existing grammar\n- For one-off grammar variations without registering globally\n\n**Behavior:**\n- When provided, this grammar is used for tokenization instead of looking up via `lang`\n- Enables highlighting even if `lang` is not in the registry (useful for custom languages)\n- The `lang` parameter is still used for metadata (data-lang attribute)\n- When undefined, the grammar is automatically looked up via `syntax_styler.get_lang(lang)`"
							},
							{
								"name": "inline",
								"type": "boolean",
								"optional": true,
								"description": "Whether to render as inline code or block code.\nControls display via CSS classes."
							},
							{
								"name": "wrap",
								"type": "boolean",
								"optional": true,
								"description": "Whether to wrap long lines in block code.\nSets `white-space: pre-wrap` instead of `white-space: pre`.\n\n**Behavior:**\n- Wraps at whitespace (spaces, newlines)\n- Long tokens without spaces (URLs, hashes) will still scroll horizontally\n- Default `false` provides traditional code block behavior\n\nOnly affects block code (ignored for inline mode)."
							},
							{
								"name": "nomargin",
								"type": "boolean",
								"optional": true,
								"description": "Whether to disable the default margin-bottom on block code.\nBlock code has `margin-bottom: var(--space_lg)` by default when not `:last-child`."
							},
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler",
								"optional": true,
								"description": "Custom SyntaxStyler instance to use for highlighting.\nAllows using a different styler with custom grammars or configuration."
							},
							{
								"name": "children",
								"type": "Snippet<[markup: string]>",
								"optional": true,
								"description": "Optional snippet to customize how the highlighted markup is rendered.\nReceives the generated HTML string as a parameter."
							}
						],
						"source_line": 1
					}
				],
				"dependencies": ["syntax_styler_global.ts"]
			},
			{
				"path": "CodeHighlight.svelte",
				"declarations": [
					{
						"name": "CodeHighlight",
						"kind": "component",
						"props": [
							{
								"name": "content",
								"type": "string",
								"description": "The source code to syntax highlight."
							},
							{
								"name": "lang",
								"type": "string | null",
								"optional": true,
								"description": "Language identifier (e.g., 'ts', 'css', 'html', 'json', 'svelte', 'md').\n\n**Purpose:**\n- When `grammar` is not provided, used to look up the grammar via `syntax_styler.get_lang(lang)`\n- Used for metadata: sets the `data-lang` attribute and determines `language_supported`\n\n**Special values:**\n- `null` - Explicitly disables syntax highlighting (content rendered as plain text)\n- `undefined` - Falls back to default ('svelte')\n\n**Relationship with `grammar`:**\n- If both `lang` and `grammar` are provided, `grammar` takes precedence for tokenization\n- However, `lang` is still used for the `data-lang` attribute and language detection"
							},
							{
								"name": "mode",
								"type": "HighlightMode",
								"optional": true,
								"description": "Highlighting mode for this component.\n\n**Options:**\n- `'auto'` - Uses CSS Custom Highlight API if supported, falls back to HTML mode\n- `'ranges'` - Forces CSS Custom Highlight API (requires browser support)\n- `'html'` - Forces HTML generation with CSS classes\n\n**Note:** CSS Custom Highlight API has limitations and limited browser support.\nRequires importing `theme_highlight.css` instead of `theme.css`."
							},
							{
								"name": "grammar",
								"type": "SyntaxGrammar | undefined",
								"optional": true,
								"description": "Optional custom grammar object for syntax tokenization.\n\n**When to use:**\n- To provide a custom language definition not registered in `syntax_styler.langs`\n- To use a modified/extended version of an existing grammar\n- For one-off grammar variations without registering globally\n\n**Behavior:**\n- When provided, this grammar is used for tokenization instead of looking up via `lang`\n- Enables highlighting even if `lang` is not in the registry (useful for custom languages)\n- The `lang` parameter is still used for metadata (data-lang attribute)\n- When undefined, the grammar is automatically looked up via `syntax_styler.get_lang(lang)`"
							},
							{
								"name": "inline",
								"type": "boolean",
								"optional": true,
								"description": "Whether to render as inline code or block code.\nControls display via CSS classes."
							},
							{
								"name": "wrap",
								"type": "boolean",
								"optional": true,
								"description": "Whether to wrap long lines in block code.\nSets `white-space: pre-wrap` instead of `white-space: pre`.\n\n**Behavior:**\n- Wraps at whitespace (spaces, newlines)\n- Long tokens without spaces (URLs, hashes) will still scroll horizontally\n- Default `false` provides traditional code block behavior\n\nOnly affects block code (ignored for inline mode)."
							},
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler",
								"optional": true,
								"description": "Custom SyntaxStyler instance to use for highlighting.\nAllows using a different styler with custom grammars or configuration."
							},
							{
								"name": "children",
								"type": "Snippet<[markup: string]>",
								"optional": true,
								"description": "Optional snippet to customize how the highlighted markup is rendered.\n- In HTML mode: receives the generated HTML string\n- In range mode: receives the plain text content"
							}
						],
						"source_line": 1
					}
				],
				"dependencies": ["highlight_manager.ts", "syntax_styler_global.ts", "tokenize_syntax.ts"]
			},
			{
				"path": "grammar_clike.ts",
				"declarations": [
					{
						"name": "class_keywords",
						"kind": "variable",
						"source_line": 3,
						"type_signature": "\"class|extends|implements|instanceof|interface|new\""
					},
					{
						"name": "add_grammar_clike",
						"kind": "function",
						"doc_comment": "Based on Prism (https://github.com/PrismJS/prism)\nby Lea Verou (https://lea.verou.me/)\n\nMIT license",
						"see_also": ["LICENSE"],
						"source_line": 13,
						"type_signature": "(syntax_styler: SyntaxStyler): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							}
						]
					}
				],
				"dependents": ["grammar_js.ts", "grammar_ts.ts", "syntax_styler_global.ts"]
			},
			{
				"path": "grammar_css.ts",
				"declarations": [
					{
						"name": "add_grammar_css",
						"kind": "function",
						"doc_comment": "Based on Prism (https://github.com/PrismJS/prism)\nby Lea Verou (https://lea.verou.me/)\n\nMIT license",
						"see_also": ["LICENSE"],
						"source_line": 14,
						"type_signature": "(syntax_styler: SyntaxStyler): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							}
						]
					}
				],
				"dependencies": ["grammar_markup.ts"],
				"dependents": ["syntax_styler_global.ts"]
			},
			{
				"path": "grammar_js.ts",
				"declarations": [
					{
						"name": "add_grammar_js",
						"kind": "function",
						"doc_comment": "Based on Prism (https://github.com/PrismJS/prism)\nby Lea Verou (https://lea.verou.me/)\n\nMIT license",
						"see_also": ["LICENSE"],
						"source_line": 13,
						"type_signature": "(syntax_styler: SyntaxStyler): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							}
						]
					}
				],
				"dependencies": ["grammar_clike.ts", "grammar_markup.ts"],
				"dependents": ["syntax_styler_global.ts"]
			},
			{
				"path": "grammar_json.ts",
				"declarations": [
					{
						"name": "add_grammar_json",
						"kind": "function",
						"doc_comment": "Based on Prism (https://github.com/PrismJS/prism)\nby Lea Verou (https://lea.verou.me/)\n\nMIT license",
						"see_also": ["LICENSE"],
						"source_line": 11,
						"type_signature": "(syntax_styler: SyntaxStyler): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							}
						]
					}
				],
				"dependents": ["syntax_styler_global.ts"]
			},
			{
				"path": "grammar_markdown.ts",
				"declarations": [
					{
						"name": "add_grammar_markdown",
						"kind": "function",
						"doc_comment": "Markdown grammar extending markup.\nSupports: headings, fenced code blocks (3/4/5 backticks with nesting), lists, blockquotes,\nbold, italic, strikethrough, inline code, and links.",
						"source_line": 97,
						"type_signature": "(syntax_styler: SyntaxStyler): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							}
						]
					}
				],
				"dependents": ["syntax_styler_global.ts"]
			},
			{
				"path": "grammar_markup.ts",
				"declarations": [
					{
						"name": "add_grammar_markup",
						"kind": "function",
						"doc_comment": "Based on Prism (https://github.com/PrismJS/prism)\nby Lea Verou (https://lea.verou.me/)\n\nMIT license",
						"see_also": ["LICENSE"],
						"source_line": 17,
						"type_signature": "(syntax_styler: SyntaxStyler): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							}
						]
					},
					{
						"name": "grammar_markup_add_inlined",
						"kind": "function",
						"doc_comment": "Adds an inlined language to markup.\n\nAn example of an inlined language is CSS with `<style>` tags.",
						"source_line": 105,
						"type_signature": "(syntax_styler: SyntaxStyler, tag_name: string, lang: string, inside_lang?: string): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							},
							{
								"name": "tag_name",
								"type": "string",
								"description": "- The name of the tag that contains the inlined language. This name will be treated as\ncase insensitive."
							},
							{
								"name": "lang",
								"type": "string",
								"description": "- The language key."
							},
							{
								"name": "inside_lang",
								"type": "string",
								"default_value": "'markup'"
							}
						]
					},
					{
						"name": "grammar_markup_add_attribute",
						"kind": "function",
						"doc_comment": "Adds an pattern to style languages embedded in HTML attributes.\n\nAn example of an inlined language is CSS with `style` attributes.",
						"source_line": 156,
						"type_signature": "(syntax_styler: SyntaxStyler, attr_name: string, lang: string): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							},
							{
								"name": "attr_name",
								"type": "string",
								"description": "- The name of the tag that contains the inlined language. This name will be treated as\ncase insensitive."
							},
							{
								"name": "lang",
								"type": "string",
								"description": "- The language key."
							}
						]
					}
				],
				"dependents": [
					"grammar_css.ts",
					"grammar_js.ts",
					"grammar_svelte.ts",
					"syntax_styler_global.ts"
				]
			},
			{
				"path": "grammar_svelte.ts",
				"declarations": [
					{
						"name": "add_grammar_svelte",
						"kind": "function",
						"doc_comment": "Based on `prism-svelte` (https://github.com/pngwn/prism-svelte)\nby pngwn (https://github.com/pngwn)\n\nMIT license",
						"see_also": ["LICENSE"],
						"source_line": 14,
						"type_signature": "(syntax_styler: SyntaxStyler): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							}
						]
					},
					{
						"name": "grammar_svelte_add_inlined",
						"kind": "function",
						"source_line": 159,
						"type_signature": "(syntax_styler: SyntaxStyler, tag_name: string, lang: string): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							},
							{
								"name": "tag_name",
								"type": "string"
							},
							{
								"name": "lang",
								"type": "string"
							}
						]
					}
				],
				"dependencies": ["grammar_markup.ts"],
				"dependents": ["syntax_styler_global.ts"]
			},
			{
				"path": "grammar_ts.ts",
				"declarations": [
					{
						"name": "add_grammar_ts",
						"kind": "function",
						"doc_comment": "Based on Prism (https://github.com/PrismJS/prism)\nby Lea Verou (https://lea.verou.me/)\n\nMIT license",
						"see_also": ["LICENSE"],
						"source_line": 12,
						"type_signature": "(syntax_styler: SyntaxStyler): void",
						"return_type": "void",
						"parameters": [
							{
								"name": "syntax_styler",
								"type": "SyntaxStyler"
							}
						]
					}
				],
				"dependencies": ["grammar_clike.ts"],
				"dependents": ["syntax_styler_global.ts"]
			},
			{
				"path": "highlight_manager.ts",
				"declarations": [
					{
						"name": "HighlightMode",
						"kind": "type",
						"source_line": 4,
						"type_signature": "HighlightMode"
					},
					{
						"name": "supports_css_highlight_api",
						"kind": "function",
						"doc_comment": "Check for CSS Highlights API support.",
						"source_line": 9,
						"type_signature": "(): boolean",
						"return_type": "boolean",
						"parameters": []
					},
					{
						"name": "HighlightManager",
						"kind": "class",
						"doc_comment": "Manages highlights for a single element.\nTracks ranges per element and only removes its own ranges when clearing.",
						"source_line": 16,
						"members": [
							{
								"name": "element_ranges",
								"kind": "variable",
								"type_signature": "Map<string, Array<Range>>"
							},
							{
								"name": "constructor",
								"kind": "constructor",
								"type_signature": "(): HighlightManager",
								"parameters": []
							},
							{
								"name": "highlight_from_syntax_tokens",
								"kind": "function",
								"doc_comment": "Highlight from syntax styler token stream.",
								"type_signature": "(element: Element, tokens: SyntaxTokenStream): void",
								"return_type": "void",
								"parameters": [
									{
										"name": "element",
										"type": "Element"
									},
									{
										"name": "tokens",
										"type": "SyntaxTokenStream"
									}
								]
							},
							{
								"name": "clear_element_ranges",
								"kind": "function",
								"doc_comment": "Clear only this element's ranges from highlights.",
								"type_signature": "(): void",
								"return_type": "void",
								"parameters": []
							},
							{
								"name": "destroy",
								"kind": "function",
								"type_signature": "(): void",
								"return_type": "void",
								"parameters": []
							}
						]
					}
				],
				"dependencies": ["highlight_priorities.ts"],
				"dependents": ["CodeHighlight.svelte"]
			},
			{
				"path": "highlight_priorities.gen.ts",
				"declarations": []
			},
			{
				"path": "highlight_priorities.ts",
				"declarations": [
					{
						"name": "HighlightTokenName",
						"kind": "type",
						"source_line": 3,
						"type_signature": "HighlightTokenName"
					},
					{
						"name": "highlight_priorities",
						"kind": "variable",
						"source_line": 56,
						"type_signature": "Record<HighlightTokenName, number | undefined>"
					}
				],
				"dependents": ["highlight_manager.ts"]
			},
			{
				"path": "svelte_preprocess_fuz_code.ts",
				"declarations": [
					{
						"name": "PreprocessFuzCodeOptions",
						"kind": "type",
						"source_line": 19,
						"type_signature": "PreprocessFuzCodeOptions",
						"properties": [
							{
								"name": "exclude",
								"kind": "variable",
								"type_signature": "Array<string | RegExp>",
								"doc_comment": "File patterns to exclude."
							},
							{
								"name": "syntax_styler",
								"kind": "variable",
								"type_signature": "SyntaxStyler",
								"doc_comment": "Custom syntax styler."
							},
							{
								"name": "cache",
								"kind": "variable",
								"type_signature": "boolean",
								"doc_comment": "Enable in-memory caching."
							},
							{
								"name": "component_imports",
								"kind": "variable",
								"type_signature": "Array<string>",
								"doc_comment": "Import sources that resolve to the Code component.\nUsed to verify that `<Code>` in templates actually refers to fuz_code's Code.svelte."
							},
							{
								"name": "on_error",
								"kind": "variable",
								"type_signature": "'log' | 'throw'",
								"doc_comment": "How to handle errors."
							}
						]
					},
					{
						"name": "svelte_preprocess_fuz_code",
						"kind": "function",
						"source_line": 44,
						"type_signature": "(options?: PreprocessFuzCodeOptions): PreprocessorGroup",
						"return_type": "PreprocessorGroup",
						"parameters": [
							{
								"name": "options",
								"type": "PreprocessFuzCodeOptions",
								"default_value": "{}"
							}
						]
					}
				],
				"dependencies": ["syntax_styler_global.ts"]
			},
			{
				"path": "syntax_styler_global.ts",
				"declarations": [
					{
						"name": "syntax_styler_global",
						"kind": "variable",
						"source_line": 11,
						"type_signature": "SyntaxStyler"
					}
				],
				"dependencies": [
					"grammar_clike.ts",
					"grammar_css.ts",
					"grammar_js.ts",
					"grammar_json.ts",
					"grammar_markdown.ts",
					"grammar_markup.ts",
					"grammar_svelte.ts",
					"grammar_ts.ts",
					"syntax_styler.ts"
				],
				"dependents": ["Code.svelte", "CodeHighlight.svelte", "svelte_preprocess_fuz_code.ts"]
			},
			{
				"path": "syntax_styler.ts",
				"declarations": [
					{
						"name": "AddSyntaxGrammar",
						"kind": "type",
						"source_line": 4,
						"type_signature": "AddSyntaxGrammar"
					},
					{
						"name": "SyntaxStyler",
						"kind": "class",
						"doc_comment": "Based on Prism (https://github.com/PrismJS/prism)\nby Lea Verou (https://lea.verou.me/)\n\nMIT license",
						"see_also": ["LICENSE"],
						"source_line": 14,
						"members": [
							{
								"name": "langs",
								"kind": "variable",
								"type_signature": "Record<string, SyntaxGrammar | undefined>"
							},
							{
								"name": "add_lang",
								"kind": "function",
								"type_signature": "(id: string, grammar: SyntaxGrammarRaw, aliases?: string[] | undefined): void",
								"return_type": "void",
								"parameters": [
									{
										"name": "id",
										"type": "string"
									},
									{
										"name": "grammar",
										"type": "SyntaxGrammarRaw"
									},
									{
										"name": "aliases",
										"type": "string[] | undefined",
										"optional": true
									}
								]
							},
							{
								"name": "add_extended_lang",
								"kind": "function",
								"type_signature": "(base_id: string, extension_id: string, extension: SyntaxGrammarRaw, aliases?: string[] | undefined): SyntaxGrammar",
								"return_type": "SyntaxGrammar",
								"parameters": [
									{
										"name": "base_id",
										"type": "string"
									},
									{
										"name": "extension_id",
										"type": "string"
									},
									{
										"name": "extension",
										"type": "SyntaxGrammarRaw"
									},
									{
										"name": "aliases",
										"type": "string[] | undefined",
										"optional": true
									}
								]
							},
							{
								"name": "get_lang",
								"kind": "function",
								"type_signature": "(id: string): SyntaxGrammar",
								"return_type": "SyntaxGrammar",
								"parameters": [
									{
										"name": "id",
										"type": "string"
									}
								]
							},
							{
								"name": "stylize",
								"kind": "function",
								"doc_comment": "Generates HTML with syntax highlighting from source code.\n\n**Process:**\n1. Runs `before_tokenize` hook\n2. Tokenizes code using the provided or looked-up grammar\n3. Runs `after_tokenize` hook\n4. Runs `wrap` hook on each token\n5. Converts tokens to HTML with CSS classes\n\n**Parameter Relationship:**\n- `lang` is ALWAYS required for hook context and identification\n- `grammar` is optional; when undefined, automatically looks up via `this.get_lang(lang)`\n- When both are provided, `grammar` is used for tokenization, `lang` for metadata\n\n**Use cases:**\n- Standard usage: `stylize(code, 'ts')` - uses registered TypeScript grammar\n- Custom grammar: `stylize(code, 'ts', customGrammar)` - uses custom grammar but keeps 'ts' label\n- Extended grammar: `stylize(code, 'custom', this.extend_grammar('ts', extension))` - new language variant",
								"type_signature": "(text: string, lang: string, grammar?: SyntaxGrammar | undefined): string",
								"return_type": "string",
								"return_description": "HTML string with syntax highlighting using CSS classes (`.token_*`)",
								"parameters": [
									{
										"name": "text",
										"type": "string",
										"description": "- The source code to syntax highlight."
									},
									{
										"name": "lang",
										"type": "string",
										"description": "- Language identifier (e.g., 'ts', 'css', 'html'). Used for:\n- Grammar lookup when `grammar` is undefined\n- Hook context (`lang` field passed to hooks)\n- Language identification in output"
									},
									{
										"name": "grammar",
										"type": "SyntaxGrammar | undefined",
										"description": "- Optional custom grammar object. When undefined, automatically\nlooks up the grammar via `this.get_lang(lang)`. Provide this to use a custom\nor modified grammar instead of the registered one.",
										"default_value": "this.get_lang(lang)"
									}
								]
							},
							{
								"name": "grammar_insert_before",
								"kind": "function",
								"doc_comment": "Inserts tokens _before_ another token in a language definition or any other grammar.\n\n## Usage\n\nThis helper method makes it easy to modify existing languages. For example, the CSS language definition\nnot only defines CSS styling for CSS documents, but also needs to define styling for CSS embedded\nin HTML through `<style>` elements. To do this, it needs to modify `syntax_styler.get_lang('markup')` and add the\nappropriate tokens. However, `syntax_styler.get_lang('markup')` is a regular JS object literal, so if you do\nthis:\n\n```js\nsyntax_styler.get_lang('markup').style = {\n    // token\n};\n```\n\nthen the `style` token will be added (and processed) at the end. `insert_before` allows you to insert tokens\nbefore existing tokens. For the CSS example above, you would use it like this:\n\n```js\ngrammar_insert_before('markup', 'cdata', {\n    'style': {\n        // token\n    }\n});\n```\n\n## Special cases\n\nIf the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\nwill be ignored.\n\nThis behavior can be used to insert tokens after `before`:\n\n```js\ngrammar_insert_before('markup', 'comment', {\n    'comment': syntax_styler.get_lang('markup').comment,\n    // tokens after 'comment'\n});\n```\n\n## Limitations\n\nThe main problem `insert_before` has to solve is iteration order. Since ES2015, the iteration order for object\nproperties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\ndifferently when keys are deleted and re-inserted. So `insert_before` can't be implemented by temporarily\ndeleting properties which is necessary to insert at arbitrary positions.\n\nTo solve this problem, `insert_before` doesn't actually insert the given tokens into the target object.\nInstead, it will create a new object and replace all references to the target object with the new one. This\ncan be done without temporarily deleting properties, so the iteration order is well-defined.\n\nHowever, only references that can be reached from `syntax_styler.langs` or `insert` will be replaced. I.e. if\nyou hold the target object in a variable, then the value of the variable will not change.\n\n```js\nvar oldMarkup = syntax_styler.get_lang('markup');\nvar newMarkup = grammar_insert_before('markup', 'comment', { ... });\n\nassert(oldMarkup !== syntax_styler.get_lang('markup'));\nassert(newMarkup === syntax_styler.get_lang('markup'));\n```",
								"type_signature": "(inside: string, before: string, insert: SyntaxGrammarRaw, root?: Record<string, any>): SyntaxGrammar",
								"return_type": "SyntaxGrammar",
								"return_description": "the new grammar object",
								"parameters": [
									{
										"name": "inside",
										"type": "string",
										"description": "- The property of `root` (e.g. a language id in `syntax_styler.langs`) that contains the\nobject to be modified."
									},
									{
										"name": "before",
										"type": "string",
										"description": "- The key to insert before."
									},
									{
										"name": "insert",
										"type": "SyntaxGrammarRaw",
										"description": "- An object containing the key-value pairs to be inserted."
									},
									{
										"name": "root",
										"type": "Record<string, any>",
										"description": "- The object containing `inside`, i.e. the object that contains the\nobject to be modified.\n\nDefaults to `syntax_styler.langs`.",
										"default_value": "this.langs"
									}
								]
							},
							{
								"name": "stringify_token",
								"kind": "function",
								"doc_comment": "Converts the given token or token stream to an HTML representation.\n\nRuns the `wrap` hook on each `SyntaxToken`.",
								"type_signature": "(o: string | SyntaxTokenStream | SyntaxToken, lang: string): string",
								"return_type": "string",
								"return_description": "The HTML representation of the token or token stream.",
								"parameters": [
									{
										"name": "o",
										"type": "string | SyntaxTokenStream | SyntaxToken",
										"description": "- The token or token stream to be converted."
									},
									{
										"name": "lang",
										"type": "string",
										"description": "- The name of current language."
									}
								]
							},
							{
								"name": "extend_grammar",
								"kind": "function",
								"doc_comment": "Creates a deep copy of the language with the given id and appends the given tokens.\n\nIf a token in `extension` also appears in the copied language, then the existing token in the copied language\nwill be overwritten at its original position.\n\n## Best practices\n\nSince the position of overwriting tokens (token in `extension` that overwrite tokens in the copied language)\ndoesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\nunderstand the language definition because, normally, the order of tokens matters in the grammars.\n\nTherefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\nFurthermore, all non-overwriting tokens should be placed after the overwriting ones.",
								"type_signature": "(base_id: string, extension: SyntaxGrammarRaw): SyntaxGrammar",
								"return_type": "SyntaxGrammar",
								"return_description": "the new grammar",
								"parameters": [
									{
										"name": "base_id",
										"type": "string",
										"description": "- The id of the language to extend. This has to be a key in `syntax_styler.langs`."
									},
									{
										"name": "extension",
										"type": "SyntaxGrammarRaw",
										"description": "- The new tokens to append."
									}
								]
							},
							{
								"name": "plugins",
								"kind": "variable",
								"type_signature": "Record<string, any>"
							},
							{
								"name": "hooks_before_tokenize",
								"kind": "variable",
								"type_signature": "Array<HookBeforeTokenizeCallback>"
							},
							{
								"name": "hooks_after_tokenize",
								"kind": "variable",
								"type_signature": "Array<HookAfterTokenizeCallback>"
							},
							{
								"name": "hooks_wrap",
								"kind": "variable",
								"type_signature": "Array<HookWrapCallback>"
							},
							{
								"name": "add_hook_before_tokenize",
								"kind": "function",
								"type_signature": "(cb: HookBeforeTokenizeCallback): void",
								"return_type": "void",
								"parameters": [
									{
										"name": "cb",
										"type": "HookBeforeTokenizeCallback"
									}
								]
							},
							{
								"name": "add_hook_after_tokenize",
								"kind": "function",
								"type_signature": "(cb: HookAfterTokenizeCallback): void",
								"return_type": "void",
								"parameters": [
									{
										"name": "cb",
										"type": "HookAfterTokenizeCallback"
									}
								]
							},
							{
								"name": "add_hook_wrap",
								"kind": "function",
								"type_signature": "(cb: HookWrapCallback): void",
								"return_type": "void",
								"parameters": [
									{
										"name": "cb",
										"type": "HookWrapCallback"
									}
								]
							},
							{
								"name": "run_hook_before_tokenize",
								"kind": "function",
								"type_signature": "(ctx: HookBeforeTokenizeCallbackContext): void",
								"return_type": "void",
								"parameters": [
									{
										"name": "ctx",
										"type": "HookBeforeTokenizeCallbackContext"
									}
								]
							},
							{
								"name": "run_hook_after_tokenize",
								"kind": "function",
								"type_signature": "(ctx: HookAfterTokenizeCallbackContext): void",
								"return_type": "void",
								"parameters": [
									{
										"name": "ctx",
										"type": "HookAfterTokenizeCallbackContext"
									}
								]
							},
							{
								"name": "run_hook_wrap",
								"kind": "function",
								"type_signature": "(ctx: HookWrapCallbackContext): void",
								"return_type": "void",
								"parameters": [
									{
										"name": "ctx",
										"type": "HookWrapCallbackContext"
									}
								]
							}
						]
					},
					{
						"name": "SyntaxGrammarValueRaw",
						"kind": "type",
						"source_line": 464,
						"type_signature": "SyntaxGrammarValueRaw"
					},
					{
						"name": "SyntaxGrammarRaw",
						"kind": "type",
						"source_line": 469,
						"type_signature": "SyntaxGrammarRaw"
					},
					{
						"name": "SyntaxGrammarTokenRaw",
						"kind": "type",
						"doc_comment": "The expansion of a simple `RegExp` literal to support additional properties.\n\nThe `inside` grammar will be used to tokenize the text value of each token of this kind.\n\nThis can be used to make nested and even recursive language definitions.\n\nNote: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\neach another.\n\nNote: Grammar authors can use optional properties, but they will be normalized\nto required properties at registration time for optimal performance.",
						"source_line": 486,
						"type_signature": "SyntaxGrammarTokenRaw",
						"properties": [
							{
								"name": "pattern",
								"kind": "variable",
								"type_signature": "RegExp",
								"doc_comment": "The regular expression of the token."
							},
							{
								"name": "lookbehind",
								"kind": "variable",
								"type_signature": "boolean",
								"doc_comment": "If `true`, then the first capturing group of `pattern` will (effectively)\nbehave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token."
							},
							{
								"name": "greedy",
								"kind": "variable",
								"type_signature": "boolean",
								"doc_comment": "Whether the token is greedy."
							},
							{
								"name": "alias",
								"kind": "variable",
								"type_signature": "string | Array<string>",
								"doc_comment": "An optional alias or list of aliases."
							},
							{
								"name": "inside",
								"kind": "variable",
								"type_signature": "SyntaxGrammarRaw | null",
								"doc_comment": "The nested grammar of this token."
							}
						]
					},
					{
						"name": "SyntaxGrammarToken",
						"kind": "type",
						"doc_comment": "Grammar token with all properties required.\nThis is the normalized representation used at runtime.",
						"source_line": 516,
						"type_signature": "SyntaxGrammarToken",
						"properties": [
							{
								"name": "pattern",
								"kind": "variable",
								"type_signature": "RegExp"
							},
							{
								"name": "lookbehind",
								"kind": "variable",
								"type_signature": "boolean"
							},
							{
								"name": "greedy",
								"kind": "variable",
								"type_signature": "boolean"
							},
							{
								"name": "alias",
								"kind": "variable",
								"type_signature": "Array<string>"
							},
							{
								"name": "inside",
								"kind": "variable",
								"type_signature": "SyntaxGrammar | null"
							}
						]
					},
					{
						"name": "SyntaxGrammar",
						"kind": "type",
						"doc_comment": "A grammar after normalization.\nAll values are arrays of normalized tokens with consistent shapes.",
						"source_line": 528,
						"type_signature": "SyntaxGrammar"
					},
					{
						"name": "HookBeforeTokenizeCallback",
						"kind": "type",
						"source_line": 552,
						"type_signature": "HookBeforeTokenizeCallback"
					},
					{
						"name": "HookAfterTokenizeCallback",
						"kind": "type",
						"source_line": 553,
						"type_signature": "HookAfterTokenizeCallback"
					},
					{
						"name": "HookWrapCallback",
						"kind": "type",
						"source_line": 554,
						"type_signature": "HookWrapCallback"
					},
					{
						"name": "HookBeforeTokenizeCallbackContext",
						"kind": "type",
						"source_line": 556,
						"type_signature": "HookBeforeTokenizeCallbackContext",
						"properties": [
							{
								"name": "code",
								"kind": "variable",
								"type_signature": "string"
							},
							{
								"name": "grammar",
								"kind": "variable",
								"type_signature": "SyntaxGrammar"
							},
							{
								"name": "lang",
								"kind": "variable",
								"type_signature": "string"
							},
							{
								"name": "tokens",
								"kind": "variable",
								"type_signature": "undefined"
							}
						]
					},
					{
						"name": "HookAfterTokenizeCallbackContext",
						"kind": "type",
						"source_line": 562,
						"type_signature": "HookAfterTokenizeCallbackContext",
						"properties": [
							{
								"name": "code",
								"kind": "variable",
								"type_signature": "string"
							},
							{
								"name": "grammar",
								"kind": "variable",
								"type_signature": "SyntaxGrammar"
							},
							{
								"name": "lang",
								"kind": "variable",
								"type_signature": "string"
							},
							{
								"name": "tokens",
								"kind": "variable",
								"type_signature": "SyntaxTokenStream"
							}
						]
					},
					{
						"name": "HookWrapCallbackContext",
						"kind": "type",
						"source_line": 568,
						"type_signature": "HookWrapCallbackContext",
						"properties": [
							{
								"name": "type",
								"kind": "variable",
								"type_signature": "string"
							},
							{
								"name": "content",
								"kind": "variable",
								"type_signature": "string"
							},
							{
								"name": "tag",
								"kind": "variable",
								"type_signature": "string"
							},
							{
								"name": "classes",
								"kind": "variable",
								"type_signature": "Array<string>"
							},
							{
								"name": "attributes",
								"kind": "variable",
								"type_signature": "Record<string, string>"
							},
							{
								"name": "lang",
								"kind": "variable",
								"type_signature": "string"
							}
						]
					}
				],
				"dependencies": ["syntax_token.ts", "tokenize_syntax.ts"],
				"dependents": ["syntax_styler_global.ts"]
			},
			{
				"path": "syntax_token.ts",
				"declarations": [
					{
						"name": "SyntaxToken",
						"kind": "class",
						"source_line": 1,
						"members": [
							{
								"name": "type",
								"kind": "variable",
								"doc_comment": "The type of the token.\n\nThis is usually the key of a pattern in a `Grammar`.",
								"type_signature": "string"
							},
							{
								"name": "content",
								"kind": "variable",
								"doc_comment": "The strings or tokens contained by this token.\n\nThis will be a token stream if the pattern matched also defined an `inside` grammar.",
								"type_signature": "string | SyntaxTokenStream"
							},
							{
								"name": "alias",
								"kind": "variable",
								"doc_comment": "The alias(es) of the token.\nAlways an array, even if empty or single value.",
								"type_signature": "Array<string>"
							},
							{
								"name": "length",
								"kind": "variable",
								"type_signature": "number"
							},
							{
								"name": "constructor",
								"kind": "constructor",
								"type_signature": "(type: string, content: string | SyntaxTokenStream, alias: string | string[] | undefined, matched_str?: string): SyntaxToken",
								"parameters": [
									{
										"name": "type",
										"type": "string"
									},
									{
										"name": "content",
										"type": "string | SyntaxTokenStream"
									},
									{
										"name": "alias",
										"type": "string | string[] | undefined"
									},
									{
										"name": "matched_str",
										"type": "string",
										"default_value": "''"
									}
								]
							}
						]
					},
					{
						"name": "SyntaxTokenStream",
						"kind": "type",
						"doc_comment": "A token stream is an array of strings and `SyntaxToken` objects.\n\nSyntax token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\nthem.\n\n1. No adjacent strings.\n2. No empty strings.\n\n   The only exception here is the token stream that only contains the empty string and nothing else.",
						"source_line": 49,
						"type_signature": "SyntaxTokenStream"
					}
				],
				"dependents": ["syntax_styler.ts", "tokenize_syntax.ts"]
			},
			{
				"path": "tokenize_syntax.ts",
				"declarations": [
					{
						"name": "tokenize_syntax",
						"kind": "function",
						"doc_comment": "Accepts a string of text as input and the language definitions to use,\nand returns an array with the tokenized code.\n\nWhen the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\nThis method could be useful in other contexts as well, as a very crude parser.",
						"examples": [
							"var code = `var foo = 0;`;\nvar tokens = tokenize_syntax(code, SyntaxStyler.langs.js);\nfor (var token of tokens) {\n    if (token instanceof SyntaxToken && token.type === 'number') {\n        console.log(`Found numeric literal: ${token.content}`);\n    }\n}"
						],
						"source_line": 28,
						"type_signature": "(text: string, grammar: SyntaxGrammar): SyntaxTokenStream",
						"return_type": "SyntaxTokenStream",
						"return_description": "an array of strings and tokens, a token stream",
						"parameters": [
							{
								"name": "text",
								"type": "string",
								"description": "- a string with the code to be styled"
							},
							{
								"name": "grammar",
								"type": "SyntaxGrammar",
								"description": "- an object containing the tokens to use\n\nUsually a language definition like `syntax_styler.get_lang('markup')`."
							}
						]
					}
				],
				"dependencies": ["syntax_token.ts"],
				"dependents": ["CodeHighlight.svelte", "syntax_styler.ts"]
			}
		]
	}
}
